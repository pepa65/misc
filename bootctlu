#!/bin/bash
set +vx
# bootctlu - Setting up and registering gummiboot on Ubuntu/Void/Arch
#
# Required: util-linux(lsblk) grep sed
#           coreutils(readlink sort cut mkdir cat cp ls wc rm cd)
#           systemd(file:systemd-bootx64.efi)/wget[if not present]
#           sudo[unless run as root, or only invoked with -n/--nogo]
#   For -m/--memtest: wget tar p7zip(7z)
#   For -r/--register: efibootmgr

# Used as the UEFI boot entry name
menuname='Main boot menu'

# Used when none is specified and there are more than 1 mounted
defesp=/boot/efi

# Boot loader binary location
bootloader='/usr/lib/systemd/boot/efi/systemd-bootx64.efi'

# Downloads
gumurl='4e4.win/gummi' memurl='4e4.win/memtest.tgz' memver='8.1'

Help(){
	cat <<-EOH
		bootctlu - Setting up and registering gummiboot on Ubuntu/Void/Arch

		Usage:  bootctlu [-h|--help] [-n|--nogo] [-q|--quiet] [-v|--verbose]
		                 [-c|--cleanup] [-m|--memtest] [-r|--register]
		                 [-e|--esp <EFI-mount>]
		        -h/--help:             Only display this help text.
		        -n/--nogo:             No writing to the system at all.
		        -q/--quiet:            Only fatal errors output to the terminal.
		        -v/--verbose:          Show more detail of the actions.
		        -c/--cleanup:          Also remove no longer installed versions.
		        -m/--memtest:          Also download and set up a MemTest86 entry.
		        -r/--register:         Also register the efi-loader with UEFI.
		        -e/--esp <EFI-mount>:  EFI System Partition mountpoint, default:
		                               $defesp, can also be set in BOOTCTLU_ESP.
	EOH
}

Echo(){ # $1: message, $2: errorcode (exit if go and non-zero!)
	# If errorcode is zero, only display the message when verbose is set
	local m=$1
	if [[ $2 ]]
	then
		(($2)) && echo -e "\nABORT: $m" && exit $2
		((verbose)) || m=
	fi
	((quiet)) || echo -ne "$m"
}

specesp=$BOOTCTLU_ESP off=/dev/null
go=1 quiet=0 rd=$off verbose=0 cleanup=0 register=0 memtest=0 esp=
while (($#))
do
	case $1 in
	-n|--nogo) go=0 ;;
	-q|--quiet) quiet=1 ;;
	-v|--verbose) verbose=1 rd=/dev/stdout ;;
	-e|--esp) [[ ${2%%/*} ]] && Echo "Mountpoint '$2' must start with /" 1
		[[ $specesp ]] && Echo "WARNING: overriding BOOTCTLU_ESP with '$2'"
		specesp=$2
		shift ;;
	-c|--cleanup) cleanup=1 ;;
	-m|--memtest) memtest=1 ;;
	-r|--register) register=1 ;;
	-h|--help) Help && exit 0 ;;
	*) Help && Echo "Unrecognized commandline option '$1'" 2
	esac
	shift
done

sudo=
((EUID)) && ! sudo=$(type -P sudo) &&
	Echo "Need to escalate privilege, but sudo not present" 3
((go)) || Echo "\n### Simulation, no actual copying/writing/registering\n"

# Get EFI System Partitions
mapfile -t <<<"$($sudo lsblk -o KNAME,PARTTYPE |
	grep c12a7328-f81f-11d2-ba4b-00a0c93ec93b)"
[[ ${MAPFILE[0]} ]] || Echo "No EFI System Partitions present" 4
p=(${MAPFILE[@]%% *}) esps=${p[@]/#//dev/}
Echo "EFI System Partitions: $esps\n" 0

# Usable EFI partition must be mounted, collect all mounted
mp=$(egrep "${esps// /|}" /proc/mounts |cut -d' ' -f2)
[[ $mp ]] || Echo "No EFI System Partitions mounted" 5
Echo "Mount points of EFI partitions: $mp\n" 0

# Pick EFI mountpoint
if [[ $specesp ]]
then  # EFI-mount specified (commandline / env.variable): check if mounted
	[[ " $mp " == *" $specesp "* ]] && esp=$specesp ||
		Echo "Specified EFI mountpoint '$specesp' has no EFI partition mounted" 6
else  # No EFI-mount specified
	if [[ " $mp " == *" $defesp "* ]]
	then  # Use default if mounted
		esp=$defesp
	else  # Use the discovered one
		[[ $mp == *$'\n'* ]] &&
			Echo "More than 1 EFI System Partition mounted, must specify one" 7
		esp=$1
	fi
fi
Echo "Working with EFI mountpoint '$esp'"

# Get current boot entries
[[ -f /etc/machine-id ]] || uuidgen |tr -d '-' >/etc/machine-id
id=$(</etc/machine-id)
entries="$esp/loader/entries" iddir="$esp/$id"
versions=$(printf "%s\n" \
	$($sudo ls -1d "$iddir/linux-*" 2>$off |sed -e "s@^$iddir/linux-@@") \
	$($sudo ls -1 "$entries/$id-linux-"* 2>$off \
	|sed -e "s@^$entries/$id-linux-@@" -e 's@.conf$@@') |sort -u)
[[ $versions ]] && Echo "\nIn EFI: ${versions//$'\n'/ }\n"

# Compare current boot entries with present kernel binaries for cleanup
((cleanup)) &&
	for kernel in /boot/vmlinuz-*
	do v=$($sudo file "$kernel" |grep -o ' version [^ ]*') v=${v# version }
		[[ " $v " == ' '$versions' ' ]] && Echo "Removed from EFI: $v\n" &&
			((go)) && $sudo rm -rf -- "$iddir/linux-$v" "$entries/$id-linux-$v.conf"
	done

p=$(grep ' / ' /proc/mounts) root=${p%% *}
[[ -f /etc/os-release ]] && p=$(grep PRETTY_NAME /etc/os-release) ||
	p=$(grep DISTRIB_DESCRIPTION /etc/lsb-release)
p=${p#*\"} release=${p:0: -1}
cmdline=$(cut -d' ' -f2- /proc/cmdline)
out="$esp/loader/loader.conf"
file=$(cat <<-EOF
	#auto-entries 0
	#auto-firmware 0
	#console-mode auto
	default $id-linux-*
	timeout 6
	editor yes
EOF
)
if ((go))
then
	[[ ! -f $bootloader ]] && bootloader=$PWD/gummi && [[ ! -f gummi ]] &&
		wget -q "$gumurl"
	$sudo mkdir -p "$iddir" "$entries" "$esp/EFI/bootctlu" "$esp/EFI/Boot" ||
		Echo "Problem making required directories" 8
	[[ -f "$out" && ! $(echo -e "$file") = $(<"$out") ]] &&
		$sudo mv "$out" "$out~" &&
		Echo "\nRenaming previous loader.conf to '$out~'\n" 0
	Echo "\nWriting '$out'"
	Echo ":\n" 0
	Echo "\n"
	echo -e "$file" |$sudo tee "$out" >$rd
	Echo "\nInstalling bootloader binaries\n" 0
	$sudo cp "$bootloader" "$esp/EFI/bootctlu/gummi.efi"
	$sudo cp "$bootloader" "$esp/EFI/Boot/BOOTX64.EFI"
else
	Echo "\nWriting '$out'"
	Echo ":\n\n$file" 0
	Echo "\n"
fi
Echo "\nCopying efi-loader\n"

versions=
for f in $(printf "%s\n" /boot/vmlinuz-* |sort -Vr)
do
	if [[ $release = void ]]
	then
		[[ $(xbps-query -o "$f") ]] && versions+="${f#*-} "
	else
		[[ $(dpkg -S "$f") ]] && versions+="${f#*-} "
	fi
done

for v in $versions
do
	path="$iddir/linux-$v"
	[[ $release = void ]] && initrd="/boot/initramfs-$v.img" ||
		initrd="/boot/initrd.img-$v"
	((go)) && ! $sudo mkdir -p "$path" &&
		Echo "Problem making directory $path" 9
	Echo "\nCopying files to $path\n"
	((go)) && $sudo cp "/boot/vmlinuz-$v" "$path/linux"
	((go)) && $sudo cp "$initrd" "$path/initrd"
	out="$entries/$id-linux-$v.conf"
	Echo "\nWriting '$out'"
	Echo ":" 0
	Echo "\n"
	file=$(cat <<-EOF
		title $release on $root (linux-$v)
		version $v
		machine-id $id
		options $cmdline
		linux /$id/linux-$v/linux
		initrd /$id/linux-$v/initrd
	EOF
	)
	((go)) && Echo "\n" 0 && echo -e "$file" |$sudo tee "$out" >$rd ||
		Echo "\n$file\n" 0
done

if ((memtest))
then
	Echo "\nDownloading and extracting MemTest86...\n"
	memdir="$id/memtest86"
	tmp=$(mktemp -d)
	cd "$tmp"
	wget -q "$memurl" || Echo "Can't download MemTest86" 10
	((go)) && $sudo mkdir -p "$esp/$memdir" && $sudo rm -rf -- "$esp/$memdir/*"
	((go)) &&
		! $sudo tar xf memtest.tgz --no-same-owner -C "$esp/$memdir" &&
		Echo "Can't setup the files for MemTest86" 11
	cd -
	rm -r -- "$tmp"
	out="$entries/$id-memtest86.conf"
	Echo "\nWriting '$out'"
	Echo ":" 0
	Echo "\n"
	file=$(cat <<-EOF
		title MemTest86
		version $memver
		efi $memdir/BOOTX64.efi
	EOF
	)
	((go)) && Echo "\n" 0 && echo -e "$file" |$sudo tee "$out" >$rd ||
		Echo "\n$file\n" 0
fi

if ((register))
then
	[[ ! -d /sys/firmware/efi/efivars ]] &&
		Echo "Not in UEFI mode, no EFI variables, unable to register" 12
	Echo "\nRegistering the bootloader with UEFI\n"
	ebm=$(type -P efibootmgr) ||
		Echo "Can't register with UEFI, efibootmgr not available" 13
	entries=$($sudo $ebm |grep " $menuname$" |grep -o 'Boot....')
	for e in $entries
	do
		((go)) && $sudo $ebm -b ${e:4:4} -B >$off
		Echo "\nUEFI entry '$e $menuname' removed" 0
	done
	echo
	((go)) && $sudo $ebm -c -l '\EFI\bootctlu\gummi.efi' -L "$menuname" &&
		Echo "\nSuccessfully registered $menuname\n" 0
else
	Echo "\nNot registering with UEFI, no -r/--register option given\n" 0
fi

((go)) ||
	Echo "\n### End of simulation, nothing actually copied/written/registered\n"

exit 0
