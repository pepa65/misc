#!/bin/bash
set +vx
## mgcfs - Manage access to gocryptfs encrypted directory
## Required: gocryptfs(http://github/com/rfjakob/gocryptfs) fuse grep procps
##   tar coreutils(cat type ls mktemp stat shred mkdir chmod sleep sync)
## Optional: zenity/whiptail/cryptsetup(askpass) gpg <run>
## Optional environment variables: $MGCFS_MOUNT/DIR/NAME/RUN/PLAIN/GPGID
##   (MGCFS_DIR and MGCFS_NAME can be overridden on the commandline)

## Mountpoint, must start with '/'; can be overridden with $MGCFS_MOUNT
mount="$HOME/Private"
## Containing directory; can be overridden with $MGCFS_DIR
dir="$HOME/SECURE"
## Name of encrypted directory; can be overridden with $MGCFS_NAME
name="SECRET"
## <run> is executed after mounting; can be overridden with $MGCFS_RUN
run=""
## Option used for Init: use plain (1) or encrypted (0) filenames;
##   can be overridden with $MGCFS_PLAIN
plain=0
## Logfile for gocryptfs operations
log="$HOME/gocryptfs.log"

Help(){
	cat <<-EOS
		mgcfs - Manage access to gocryptfs encrypted directory
		USAGE: mgcfs [-c|--console] | [-w|--whiptail] [-i|--init [<dir> [<name>]] |
	           [-v|--verbose] [-u|--unmount <sleeplength>[<unit>]] | [-h|--help]
		  -c/--console:  display through echo is forced instead of whiptail
		  -w/--whiptail: display through whiptail is forced instead of zenity
		  -i/--init:     setting up, <dir> must exist and <name> not or be empty
		  -v/--verbose:  echoing the masterpassword to the terminal on mounting
		  -u/--unmount:  auto-unmount after <sleeplength>[<unit>]
		  -h/--help:     display this help text
		Either set or adjust <mount>, <dir> and <name> as hardcoded in this script
		  (and optionally <run>), or set the corresponding environment variables
		  MGCFS_MOUNT, MGCFS_DIR, MGCFS_NAME (and optionally MGCFS_RUN);
		  if MGCFS_GPGID is set, the tar (backup) archive is encrypted.
		As a run-by-run backup, <dir>/<name>.tar will be used.
		When during 'init' MGCFS_PLAIN is 1, filenames will not be encrypted.
		<sleeplength> is in minutes if no unit is given; <unit> can be:
		  s (seconds), m (minutes), h (hours), d (days).
	EOS
	exit 0
}

Info(){  ## $1: Info message, Using: zenity whiptail
	if ((zenity))
	then
		zenity --info --width=360 --title="$title" --text="<b>$1</b>" 2>/dev/null
	elif ((whiptail))
	then
		whiptail --title="$title" --msgbox "$1" 11 78
	else
		echo -e "=== $title ===\n$1"
	fi
}

Abort(){  ## $1: Error message
	Info "ERROR: $1"
	exit 2
}

Unmount(){  ## Using: mount name
	## When mounted: keep trying to unmount
	if grep "$mount" <<<"$(mount)" |grep -q ' fuse\.gocryptfs '
	then
		while ! fusermount -zqu "$mount"
		do
			Info "Unable to unmount $name:\n\n$mount\n\nTrying again in a minute."
			sleep 1m
		done
		Info "Now unmounted $name from:\n\n$mount"
		exit 0
	fi
}

Password(){  ## $1: text, Using: zenity whiptail title pass
	local cancel=0 console=0
	if ((zenity))
	then
		zenity --entry --hide-text --width=360 --title="$title" --text="$1" 2>/dev/null ||
			cancel=1
	elif ((whiptail))
	then
		whiptail --clear --title "$title" --passwordbox "$1" 16 78 3>&1 1>&2 2>&3 ||
			cancel=1
	else
		console=1
		echo -ne "=== $title ===\n$1" 1>&2
		/lib/cryptsetup/askpass ""
		echo
	fi >"$pass"
	## Cancel -c/--console mode with empty password
	((console)) && [[ $(echo $(hexdump -b "$pass")) = "0000000 012 0000001" ]] &&
		echo "Exited: empty password" && cancel=1
	((cancel)) || return 0
	shred -fu -- "$pass"
	exit 1
}

## Main

self=$(basename $0)
mount=${MGCFS_MOUNT:-$mount}
dir=${MGCFS_DIR:-$dir}
name=${MGCFS_NAME:-$name}
run=${MGCFS_RUN:-$run}
plain=${MGCFS_PLAIN:-$plain}
gpgid=$MGCFS_GPGID

title="Manage encryption of $name"
## Try zenity unless -c or -w or not present or no GUI
zenity=1 init=0 sleep= q='-q'
type -P zenity >/dev/null && xrandr &>/dev/null || zenity=0

while (($#))
do
	case $1 in
	-h|--help) Help ;;
	-v|--verbose) q= ;;
	-c|--console) zenity=0 whiptail=0 ;;
	-w|--whiptail) zenity=0 whiptail=1 ;;
	-u|--unmount) [[ $2 ]] || Abort "Must have a sleeplength after '$1'"
		sleep=$2
		shift
		shopt -s extglob
		len='^[0-9]*([.][0-9]*)?[smhd]?$' dot='^[.][smhd]?$' unit='[smhd]'
		[[ $sleep =~ $len && ! $sleep =~ $dot ]] ||
			Abort "Bad sleeplength after -u/--unmount: '$sleep'"
		[[ ${sleep: -1:1} =~ $unit ]] || sleep=${sleep}m ;;
	-i|--init) init=1
		if [[ $2 && ! ${2:0:1} = "-" ]]
		then
			dir=$2
			shift
			[[ $2 && ! ${2:0:1} = "-" ]] && name=$2 && shift
		fi ;;
	*) Abort "Unrecognized argument: '$1'"
	esac
	shift
done
dn="$dir/$name"

((whiptail)) && ! type -P whiptail >/dev/null && whiptail=0
type -P gocryptfs >/dev/null ||
	Abort "Install gocryptfs first: https://4e4.win/bgcfs"

trap "[[ -s '$log' ]] || rm -f -- '$log'" EXIT QUIT
if ((init))
then
	[[ $dir ]] ||
		Abort "Either set $MGCFS_DIR or $dir, or put a directory after '-i/--init'"
	[[ $name ]] ||
		Abort "Either set $MGCFS_NAME or $name, or put a name after '-i/--init <dir>'"
	[[ -d $dn ]] || mkdir -p "$dn" ||
		Abort "Initialize failed, unable to create directory '$dn'"
	[[ $(ls -A "$dn") ]] && Abort "Initialize failed, directory '$dn' not empty"
	[[ $MGCFS_PLAIN = 1 ]] && ptn="-plaintextnames " || ptn=
	pass=$(mktemp)
	cue=
	while :
	do
		Password "${cue}Enter new password:"
		(($(stat -c '%s' "$pass")<2)) && cue="Password cannot be empty!\n" && continue
		first=$(cat "$pass")
		Password "Confirm password:"
		[[ "$(cat "$pass")" = "$first" ]] && break || cue="Passwords not the same!\n"
	done
	gocryptfs -passfile "$pass" -init $ptn -- "$dn" >"$log" &&
		shred -fu -- "$pass" &&
		Info "Directory '$dn' initialized as gocryptfs directory" &&
		exit 0 ||
		Abort "Initializing '$dn' as gocryptfs directory failed"
fi

## When mounted: unmount+exit
Unmount
## Directory not FUSE-mounted
if mkdir -p "$mount" 2>/dev/null
then  ## Directory now exists
	chmod 700 "$mount"  ## Force access restriction
else  ## $mount could not be created: abort
	Abort "Mount point $mount could not be created or\nalready exists and isn't a directory"
fi

## If $name is no directory or is empty, unpack $name.tar[.gpg] if present
ungpg=0
if [[ ! -d $dn || -z $(ls -A "$dn") ]]
then
	if [[ $gpgid && -f $dn.tar.gpg ]]
	then
		Info "No files in '$dn'\n,decrypting '$dn.tar.gpg'"
		gpg -r "$gpgid" -o "$dn.tar" -d "$dn.tar.gpg"
		ungpg=1
	fi
	if [[ -f $dn.tar ]]
	then
		((ungpg)) || Info "No files in '$dn'\n,unpacking '$dn.tar'"
		tar xf "$dn.tar" -C "$dir"
		shred -fu "$dn.tar"
	fi
fi
[[ -s $dn/gocryptfs.conf ]] || Abort "$dn is not a gocryptfs directory"

pass=$(mktemp)
[[ $sleep ]] && cue="(Will auto-unmount $name after $sleep)" ||
	cue="(Run again to manually unmount $name!)"
cue="Mounting $name on $mount\n$cue\n\nPassword:"
Password "$cue"
## Allow mounting over non-empty mountpoint with -nonempty
while ! gocryptfs $q -nonempty -passfile "$pass" -- "$dn" "$mount" 2>"$log"
do
	shred -fu -- "$pass"
	Password "Decryption failed, try a different password!\n\n$cue"
done
shred -fu -- "$pass"
sync

[[ $run ]] && DISPLAY=:0.0 $run &
## Tar up the encrypted directory for backup
tar cfC "$dn.tar" "$dir" "$name" ||
	Info "Return code on creating backup archive\n'$dn.tar': $?"
[[ $gpgid ]] && gpg --yes -r "$gpgid" -e "$dn.tar" && shred -fu -- "$dn.tar"

[[ $sleep ]] && sleep $sleep && Unmount &
sync

exit 0
