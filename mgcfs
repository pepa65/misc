#!/bin/bash
set +vx
## mgcfs - Manage access to gocryptfs encrypted directory
## Required: gocryptfs(GH/rfjakob/gocryptfs) fuse tar grep procps coreutils
## Optional: zenity/xterm (otherwise: whiptail), <command>
## Optional environment variables: $MGCFS_MOUNT/DIR/NAME/COMMAND/PLAIN

## Mountpoint: set here or in $MGCFS_MOUNT, must start with '/'
mount="$HOME/Private"
## Main containing directory: set here or in $MGCFS_DIR
dir="/data/MyDocuments/SECURE"
## Name of encrypted directory: set here or in $MGCFS_NAME
name="SECRET"
## <command> to run after mounting: set here or in $MGCFS_COMMAND
command="/usr/bin/caja $mount/"
## Init with plain (1) or encrypted (0) filenames: set here or in $MGCFS_PLAIN
plain=0

Help(){
	cat <<-EOS
		mgcfs - Manage access to gocryptfs encrypted directory
		USAGE: mgcfs [-c|--console] [-u|--unmount <sleeplength>[<unit>]] |
		             [-i|--init [<dir> [<name>]] | [-h|--help]
		  -c/--console:  display through whiptail is forced instead of zenity
		  -i/--init:     setting up, <dir> must exist and <name> must not!
		  -u/--unmount:  auto-unmount after <sleeplength>[<unit>]
		  -h/--help:     display this help text
		Either set or adjust <mount>, <dir> and <name> as hardcoded in this script
		  (and optionally <command>), or set the corresponding environment variables
		  MGCFS_MOUNT MGCFS_DIR MGCFS_NAME (and optionally MGCFS_COMMAND).
		When during 'init' MGCFS_PLAIN is 1, filenames will not be encrypted. On
		  init, the commandline needs to be used for password entry!
		<sleeplength> is in minutes by default, but if <unit> can be: s (seconds),
		  m (minutes), h (hours), d (days).
	EOS
	exit 0
}

Info(){  ## $1: Info message, Using: $sleep
	((zenity)) &&
		zenity --info --title="$title" --text="<b>$1</b>" 2>/dev/null || {
			[[ $sleep ]] && echo -e "=== $title ===\n$1" ||
				whiptail --title="$title" --msgbox "$1" 11 78
		}
}

Unmount(){  ## Using: $mount, $name
	## When mounted: keep trying to unmount
	if grep "$mount" <<<"$(mount)" |grep -q ' fuse\.gocryptfs '
	then
		while ! fusermount -zqu "$mount"
		do
			Info "Unable to unmount $name:\n\n$mount\n\nTrying again in a minute."
			sleep 1m
		done
		Info "Now unmounted $name from:\n\n$mount"
		exit 0
	fi
}

Abort(){  ## $1: Error message
	Info "ERROR: $1"
	exit 2
}

Password(){  ## $1: boolean-Failed, Using: $sleep
	[[ $sleep ]] && unmount="Will auto-unmount $name after $sleep." ||
		unmount="Run again to manually unmount $name!"
	(($1)) && failed="Decryption failed, try a different password!\n\n" || failed=
	text="$failed($unmount)\n\nMounting $name on $mount\n\nPassword:"
	if ((zenity))
	then
		zenity --entry --hide-text --title="$title" --text="$text" 2>/dev/null ||
			exit 1
	else
		whiptail --title "$title" --passwordbox "$text" 16 78 3>&1 1>&2 2>&3 ||
			exit 1
	fi
}

## Main

self=$(basename $0)
mount=${MGCFS_MOUNT:-$mount}
dir=${MGCFS_DIR:-$dir}
name=${MGCFS_NAME:-$name}
command=${MGCFS_COMMAND:-$command}
plain=${$MGCFS_PLAIN:-$plain}
title="Manage encryption of $name"
dn="$dir/$name"
zenity=1 init=0 sleep=
## Validate zenity: in PATH? xterm in PATH? GUI going?
type -p zenity >/dev/null && type -p xterm >/dev/null &&
	xterm -iconic -e echo || zenity=0

while (($#))
do
	case $1 in
	-c|--console) zenity=0 ;;
	-h|--help) Help ;;
	-u|--unmount) [[ $2 ]] && sleep=$2 ||
		Abort "Must have a sleeplength after '$1'"
		len='^[0-9]*([.][0-9]*)?[smhd]?$' dot='^[.][smhd]?$' unit='[smhd]'
		[[ $sleep =~ $len && ! $sleep =~ $dot ]] ||
			Abort "Bad number after -u/--unmount: '$sleep'"
		[[ ${sleep: -1:1} =~ $unit ]] || sleep=${sleep}m
		shift ;;
	-i|--init) init=1
		if [[ $2 ]]
		then
			dir=$2
			shift
			[[ $2 ]] && name=$2 && shift
		fi ;;
	esac
	shift
done

! type -p whiptail >/dev/null && ((!zenity)) &&
	Abort "Either zenity or whiptail needs to be able to be used"

if ((init))
then
	[[ $dir ]] ||
		Abort "Either set $MGCFS_DIR or $dir, or put a directory after '-i/--init'"
	[[ -d $dir ]] || Abort "Not a directory: '$dir'"
	[[ $name ]] ||
		Abort "Either set $MGCFS_NAME or $name, or put a name after '-i/--init <dir>'"
	[[ -e $dn ]] && Abort "Here '$name' already exists: $dn"
	[[ $MGCFS_PLAIN = 1 ]] && ptn="-plaintextnames " || ptn=
	mkdir "$dn" || Abort "Unable to create '$name' in '$dir'"
	gocryptfs -init $ptn "$dn" &&
		Info "Directory '$dn' initialized as gocryptfs directory" &&
		exit 0 ||
		Abort "Initializing '$dn' as gocryptfs directory failed"
fi

## When mounted: unmount + exit
Unmount
## Directory not FUSE-mounted
if mkdir -p "$mount" 2>/dev/null
then  ## Directory now exists
	chmod 700 "$mount"  ## Force access restriction
else  ## $mount could not be created: abort
	Abort "Mount point $mount could not be created or\nalready exists and isn't a directory"
fi

## If $name doesn't exist or is empty, but $name.tar does: unpack
if [[ ! -d $dn || -z $(ls -A "$dn") ]]
then
	[[ -f $dn.tar ]] && Info "No files in $dn\n,unpacking $dn.tar" &&
		tar xf "$dn.tar" -C "$dir"
fi
[[ -s $dn/gocryptfs.conf ]] || Abort "$dn is not a gocryptfs directory"

pass=$(mktemp)
Password 0 >"$pass"
## Allow mounting over non-empty mountpoint with -nonempty
while ! gocryptfs -q -nonempty -passfile "$pass" "$dn" "$mount" 2>/dev/null
do
	shred -u "$pass"
	Password 1 >"$pass"
done
shred -u "$pass"
sync
[[ $command ]] && $command &
## Tar up the encrypted directory for backup
tar cfC "$dn.tar" "$dir" "$name"
[[ $sleep ]] && sleep $sleep && Unmount &
sync

exit 0
