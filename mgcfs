#!/bin/bash
set +vx
## mgcfs - Manage access to gocryptfs encrypted directory
## Required: gocryptfs(http://rfjakob/gocryptfs) fuse tar grep procps coreutils
## Optional: zenity (otherwise: whiptail), <run>
## Optional environment variables: $MGCFS_MOUNT/DIR/NAME/RUN/PLAIN

## Mountpoint: set here or in $MGCFS_MOUNT, must start with '/'
mount="$HOME/Private"
## Containing directory: set here or in $MGCFS_DIR
dir="$HOME/SECURE"
## Name of encrypted directory: set here or in $MGCFS_NAME
name="SECRET"
## <run> is the command to run after mounting: set here or in $MGCFS_RUN
run=
## Init with plain (1) or encrypted (0) filenames: set here or in $MGCFS_PLAIN
plain=0

Help(){
	cat <<-EOS
		mgcfs - Manage access to gocryptfs encrypted directory
		USAGE: mgcfs [-c|--console] [-u|--unmount <sleeplength>[<unit>]] |
		             [-i|--init [<dir> [<name>]] | [-h|--help]
		  -c/--console:  display through whiptail is forced instead of zenity
		  -i/--init:     setting up, <dir> must exist and <name> not or be empty
		  -u/--unmount:  auto-unmount after <sleeplength>[<unit>]
		  -h/--help:     display this help text
		Either set or adjust <mount>, <dir> and <name> as hardcoded in this script
		  (and optionally <run>), or set the corresponding environment variables
		  MGCFS_MOUNT, MGCFS_DIR, MGCFS_NAME (and optionally MGCFS_RUN).
		As a run-by-run backup, <dir>/<name>.tar will be used.
		When during 'init' MGCFS_PLAIN is 1, filenames will not be encrypted.
		<sleeplength> is in minutes if no unit given, but <unit> can be:
		  s (seconds), m (minutes), h (hours), d (days).
	EOS
	exit 0
}

Info(){  ## $1: Info message, Using: $sleep
	((zenity)) &&
		zenity --info --width=360 --title="$title" --text="<b>$1</b>" 2>/dev/null || {
			[[ $sleep ]] && echo -e "=== $title ===\n$1" ||
				whiptail --title="$title" --msgbox "$1" 11 78
		}
}

Unmount(){  ## Using: $mount, $name
	## When mounted: keep trying to unmount
	if grep "$mount" <<<"$(mount)" |grep -q ' fuse\.gocryptfs '
	then
		while ! fusermount -zqu "$mount"
		do
			Info "Unable to unmount $name:\n\n$mount\n\nTrying again in a minute."
			sleep 1m
		done
		Info "Now unmounted $name from:\n\n$mount"
		exit 0
	fi
}

Abort(){  ## $1: Error message
	Info "ERROR: $1"
	exit 2
}

Pw(){  ## $1: text; Using: $title
	if ((zenity))
	then
		zenity --entry --hide-text --width=360 --title="$title" --text="$1" 2>/dev/null |head -c -1 ||
			exit 1
	else
		whiptail --clear --title "$title" --passwordbox "$1" 16 78 3>&1 1>&2 2>&3 ||
			exit 1
	fi
}

Password(){  ## $1:failtext; Using: $sleep
	[[ $sleep ]] && unmount="Will auto-unmount $name after $sleep." ||
		unmount="Run again to manually unmount $name!"
	Pw "$1($unmount)\n\nMounting $name on $mount\n\nPassword:"
}

## Main

self=$(basename $0)
: ${mount:=$MGCFS_MOUNT}
: ${dir:=$MGCFS_DIR}
: ${name:=$MGCFS_NAME}
: ${run:=$MGCFS_RUN}
: ${plain:=$MGCFS_PLAIN}

title="Manage encryption of $name"
zenity=1 init=0 sleep=
type -p zenity >/dev/null && xhost &>/dev/null || zenity=0

while (($#))
do
	case $1 in
	-c|--console) zenity=0 ;;
	-h|--help) Help ;;
	-u|--unmount) [[ $2 ]] && sleep=$2 ||
			Abort "Must have a sleeplength after '$1'"
		len='^[0-9]*([.][0-9]*)?[smhd]?$' dot='^[.][smhd]?$' unit='[smhd]'
		[[ $sleep =~ $len && ! $sleep =~ $dot ]] ||
			Abort "Bad sleeplength after -u/--unmount: '$sleep'"
		[[ ${sleep: -1:1} =~ $unit ]] || sleep=${sleep}m
		shift ;;
	-i|--init) init=1
		if [[ $2 && ! ${2:0:1} = - ]]
		then
			dir=$2
			shift
			[[ $2 && ! ${2:0:1} = - ]] && name=$2 && shift
		fi ;;
	esac
	shift
done
dn="$dir/$name"

! type -p whiptail >/dev/null && ((!zenity)) &&
	Abort "Either zenity or whiptail needs to be usable"
type -p gocryptfs >/dev/null ||
	Abort "Install gocryptfs from http://github.com/rfjakob/gocryptfs first!"

if ((init))
then
	[[ $dir ]] ||
		Abort "Either set $MGCFS_DIR or $dir, or put a directory after '-i/--init'"
	[[ $name ]] ||
		Abort "Either set $MGCFS_NAME or $name, or put a name after '-i/--init <dir>'"
	[[ -d $dn ]] || mkdir -p "$dn" ||
		Abort "Initialize failed, unable to create directory '$dn'"
	[[ $(ls -A "$dn") ]] && Abort "Initialize failed, directory '$dn' not empty"
	[[ $MGCFS_PLAIN = 1 ]] && ptn="-plaintextnames " || ptn=
	pass=$(mktemp)
	cue=
	while Pw "${cue}Enter password:" >"$pass"
	do
		[[ -z $(head -c 1 "$pass") ]] && cue="Password cannot be empty.\n" && continue
		[[ $(cat "$pass") = $(Pw "Confirm password:") ]] && break
		cue="Passwords not the same.\n"
	done
	gocryptfs -passfile "$pass" -init $ptn "$dn" >/dev/null &&
		shred -fu "$pass" &&
		Info "Directory '$dn' initialized as gocryptfs directory" &&
		exit 0 ||
		Abort "Initializing '$dn' as gocryptfs directory failed"
fi

## When mounted: unmount + exit
Unmount
## Directory not FUSE-mounted
if mkdir -p "$mount" 2>/dev/null
then  ## Directory now exists
	chmod 700 "$mount"  ## Force access restriction
else  ## $mount could not be created: abort
	Abort "Mount point $mount could not be created or\nalready exists and isn't a directory"
fi

## If $name doesn't exist or is empty, but $name.tar does: unpack
if [[ ! -d $dn || -z $(ls -A "$dn") ]] && [[ -f $dn.tar ]]
then
	Info "No files in '$dn'\n,unpacking '$dn.tar'"
	tar xf "$dn.tar" -C "$dir"
fi
[[ -s $dn/gocryptfs.conf ]] || Abort "$dn is not a gocryptfs directory"

pass=$(mktemp)
Password >"$pass"
## Allow mounting over non-empty mountpoint with -nonempty
while ! gocryptfs -q -nonempty -passfile "$pass" "$dn" "$mount" 2>/dev/null
do
	shred -fu "$pass"
	Password "Decryption failed, try a different password!\n\n" >"$pass"
done
shred -fu "$pass"
sync
[[ $run ]] && $run &
## Tar up the encrypted directory for backup
tar cfC "$dn.tar" "$dir" "$name" ||
	Info "Unable to create backup archive\n'$dn.tar'!"
[[ $sleep ]] && sleep $sleep && Unmount &
sync

exit 0
