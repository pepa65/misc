#!/usr/bin/env bash
set +vx
# buildnano - Build nano from source (release or git repo) on Ubuntu or Debian
# Required: coreutils(mkdir cd mktemp rm)
#   git+autoconf+autopoint+automake/wget[git/release]
#   pkg-config gettext libncursesw5-dev groff[optional html-help]
#   texinfo make gcc libmagic-dev[optional filetype detection]

Help(){
	echo "Usage: buildnano [<version> | -g|--git | -c|--current] -h
    <version>:     Build <version>
    -g/--git:      Build from current git HEAD (not stable release version)
    -c/--current:  Build from local git repo (as is)
    -h/--help:     This help text"
	exit 0
}

[[ ' '$*' ' = *' -h '* || ' '$*' ' = *' --help '* ]] && Help

# Configuration options to (un)comment-out
conf=(
	#disable-browser
	#disable-color
	disable-comment
	disable-extra
	disable-help
	#disable-histories
	disable-justify
	#disable-libmagic
	#disable-linenumbers
	disable-mouse
	#disable-multibuffer
	#disable-nanorc
	disable-operatingdir
	disable-speller
	#disable-tabcomp
	#disable-wordcomp
	disable-wrapping
	#enable-tiny
	#disable-wrapping-as-root
	#disable-nls
)

# Location of git repos, can be passed in environment variable GITDIR
gitdir=${GITDIR:=~/git}
# URL of nano git repo
nanogit="http://git.savannah.gnu.org/git/nano.git"

# URL of latest release
nanosrcdir="https://nano-editor.org/dist/latest"

# Required packages
req="pkg-config libncursesw5-dev libmagic-dev texinfo gettext groff build-essential"


Abort(){ # $1:message
	echo "ABORT: $1"
	exit 1
}

Sudo(){ # $@:command+arguments
	echo "Elevated privileges required"
	sudo "$@"
}

[[ $- = *i* ]] && echo "Don't source, but run like: bash $BASH_SOURCE" &&
	return 2

sudo=
if ((EUID))
then
	sudo=$(type -p sudo) ||
		Abort "package sudo required to elevate privilege for installing"
fi

nanorc=$(cat <<\EORC
# ~/.nanorc
# Syntaxfiles:
include /usr/local/share/nano/*.nanorc

# Enhanced syntaxfiles: git clone https://github.com/scopatz/nanorc.git ~/.nano
#include ~/.nano/*.nanorc

# Colors: [bold|italic,][light]white|black|blue|green|red|cyan|yellow|magenta |
#  pink|purple|mauve|lagoon|mint|lime|peach|orange|latte|normal
set titlecolor black,lightwhite
set statuscolor brightwhite,cyan
set errorcolor brightyellow,red
set selectedcolor black,lightyellow
set stripecolor brightred,normal
set numbercolor black,cyan
set keycolor blue,yellow
set functioncolor cyan,white
#set scrollercolor yellow,cyan

unset afterends
unset allow_insecure_backup
unset atblanks # softwrap at whitespace
unset autoindent
unset backup
#set backupdir <dir>
unset boldtext
unset bookstyle
#set brackets <string> # default: ""')>]}"
###unset breaklonglines
set casesensitive
set constantshow # overrides: set quickblank
unset cutfromcursor
unset emptyline
##set fill -1 # conflicts with: set nowrap; last option given takes effect
set guidestripe 80
set historylog
unset indicator
unset jumpyscrolling
unset linenumbers
unset locking
set magic
#set matchbrackets "(<[{)>]}"
set minibar
##set morespace
###unset mouse
set multibuffer
set noconvert # overrides: set unix
set nohelp
set nonewlines
##unset nopauses
##set nowrap # conflicts with: set fill; last option given takes effect
#set operatingdir <directory>
set positionlog
unset preserve
#set punct "!.?"
unset quickblank # overridden by: set constantshow
#set quotestr "^([ \t]*[!#%:;>|}]|//))+" # "> " if no EREGEX
unset rawsequences
unset rebinddelete # set this when Backspace behaves like Delete
unset regexp
unset saveonexit
set showcursor
unset smarthome
##set smooth
set softwrap
#set speller enchant
set stateflags
set suspendable
set tabsize 2
unset tabstospaces
unset tempfile
unset trimblanks
unset unix # overridden by: set noconvert
#set whitespace "»⋅" (non-utf8: ">.")
##set whitespace $'\e[32m'" "$'\e[0m'
unset wordbounds # overridden by: set wordchars
#set wordchars <string> # overrides: set wordbounds
set zap

#bind ^\ nextbookmark all
# ^@ ^] ^\ ^, ^_ ^Space M-[^[] F1-16
unbind ^H all
##bind ^H help all
##bind ^H exit help
bind M-X cancel all
bind Sh-M-L refresh main
bind ^Q exit all
bind ^O insert all
bind M-I autoindent all
bind M-K cutfromcursor all
bind M-B flipnewbuffer insert
bind ^F whereis all
bind M-F wherewas all
bind ^G findnext all
bind M-G findprevious all
bind M-V verbatim all
bind ^Y cut all
bind ^X cut all
bind ^U paste all
bind ^V paste all
bind M-A firstline all
bind M-E lastline all
bind ^L gotoline all
bind ^R replace all
bind ^B mark all
bind ^C copy main
bind M-B findbracket all
bind Sh-M-N prevbuf all
bind M-N nextbuf all
bind M-O enter all
bind Sh-M-C wordcount all
bind M-R regexp search
bind M-R regexp replace
bind M-S flipreplace search
bind M-S flipreplace replace
bind M-D backwards search
bind M-D backwards replace
bind M-C casesens search
bind M-C casesens replace
bind M-C complete main
bind ^Z undo all
bind M-Z redo all
bind Sh-M-Z suspend all
bind M-W whitespacedisplay all
bind ^S savefile all
bind M-S writeout all
bind M-| recordmacro all
bind M-\ runmacro all
bind M-' nosyntax all
bind ^T anchor all
bind M-, prevanchor all
bind M-< nextanchor all

bind M-L linenumbers all
bind ^W softwrap all
# cut all forward
unbind M-T all
# delete
unbind ^D all

unbind F9 all
# Unbind un-undoable actions:

# Justify keys
unbind ^J main
unbind F4 main
unbind M-J all
#bind M-J speller main

# Spell checker
#unbind ^T main
unbind F12 all

## Make sure no 'formatter' option is set!
bind Ins "" all
#bind ^J bookmark all
EORC
)

git=0 cur=0
if [[ $1 ]]
then
	if [[ $1 = -g || $1 = --git ]]
	then git=1 req+=" git autoconf autopoint makedev"
	elif [[ $1 = -c || $1 = --current ]]
	then git=1 cur=1 req+=" autoconf autopoint"
	else
		[[ $1 =~ ^[45]\.[0-9]$ ]] &&
			ver=$1 ||
			Abort "argument not -g/--git or -c/--current, or bad version: $1"
	fi
else
	req+=" wget"
fi

# Install missing packages

pkgs=$(dpkg -l) inst=
for p in $req
do grep -q "^ii  $p[ :]" <<<$pkgs || inst+=" $p"; done
[[ $inst ]] && echo "Need to install$inst" &&
	! Sudo apt-get install $inst && Abort "could not install packages:$inst"

if ((cur))
then
	[[ ! -d $gitdir/nano ]] &&
		Abort "$gitdir/nano must be buildable already for -c/--current"
	cd $gitdir/nano
elif ((git))
then
	# Prepare git repo clone
	[[ ${gitdir:0:1} = / ]] || Abort "GITDIR not an absolute path: $gitdir"
	mkdir -p "$gitdir" || Abort "$gitdir not a directory"
	cd "$gitdir" || Abort "could not enter git directory $gitdir"

	# Pull when repo present already
	if [[ -d nano/.git ]]
	then
		cd nano || Abort "could not enter directory $gitdir/nano"
		#git checkout master
		# Delete on unsuccessful pull
		! git pull && cd .. && rm -rf -- nano
	fi
	[[ ! -d nano ]] && ! git clone $nanogit &&
		Abort "could not download the nano git repo"
	cd nano
else
	# Build in temporary directory in PWD
	tmpdir=$(mktemp -d "./nano.XXXXXX")
	tmpdir=$(readlink -e "$tmpdir") here=$PWD
	trap "cd '$here'; rm -rf -- '$tmpdir'" QUIT EXIT
	cd "$tmpdir" || Abort "could not enter directory $tmpdir"
	wget -q "$nanosrcdir/ChangeLog" ||
		Abort "could not download nano changelog"
	[[ $ver ]] || ver=$(head -1 ChangeLog) ver=${ver##* v} ver=${ver%:}
	wget -q "$nanosrcdir/nano-$ver.tar.xz" ||
		Abort "could not download nano source archive version $ver"
	file="nano-$ver.tar.xz"
	tar xf "$file" || Abort "could not unpack $file"
	dir="nano-$ver"
	cd "$dir" || Abort "could not enter directory $tmpdir/$dir"
fi

# Needs: autoconf autopoint
if ((git))
then ./autogen.sh || Abort "error in Autogen"
fi

# Needs: gcc pkg-config libncursesw5-dev gettext(groff)
./configure ${conf[@]/#/--} || Abort "error in Configure"

# Needs: make texinfo
make || Abort "error in Make"

# Needs: make sudo
Sudo make install || Abort "error in Install"
rc=$HOME/.nanorc

echo -e "$nanorc" >"$rc.tmp"
[[ -f $rc ]] && ! diff $rc $rc.tmp && mv -v --backup=t "$rc.tmp" "$rc"
hash -r nano
echo "Installed $(nano -V)"

exit 0
